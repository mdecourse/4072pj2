var tipuesearch = {"pages": [{'title': 'About', 'text': '專題題目: \n 有限元素分析套件之應用研究 - 以 Abaqus, Range3 與 NGSolve 為例 \n Application study on finite element packages - taking Abaqus, Range3 and NGSolve as examples \n 討論區:  https://github.com/mdecourse/4072pj2/discussions \n 組員: \n 40723212 \n 40723216 \n 40723223\xa0\xa0 \n 40723246 \n \n table_of_greek_letters.pdf \n Mathmatical Symbols:  https://en.wikipedia.org/wiki/Table_of_mathematical_symbols_by_introduction_date \n \n', 'tags': '', 'url': 'About.html'}, {'title': 'About FEM', 'text': "有限元素分析，即使用有限元素法（英文：finite element method）分析物理現象，是一種用於求解微分方程組或積分方程組數值解的數值方法，它能運用在各種工程上的問題，像結構分析，熱傳遞，流體流動，質量傳輸和電磁勢的傳統領域。 \n 偏微分方程式:$f(x) = \\int_{0}^{x} f'(t)dt$ \n 在解偏微分方程的過程中，主要難點是如何構造一個方程來接近原本研究的方程，並且該過程還需要保持數值穩定性。目前有許多處理的方法，他們各有好壞。當區域改變時（就像一個邊界可變的固體），當需要的精確度在整個區域上變化，或者當解缺少光滑性時，有限元素方法是在複雜區域上解偏微分方程的一個很好的選擇。 為了解決問題，有限元素法將大型物理系統細分為更小、更簡單的部分，稱為有限元（英文：finite element）。這是通過在空間維度上進行特定的空間離散化來實現，離散化是通過構建對象的網格實現的：解決方案的數值域具有有限數量的點。邊值問題的有限元素法公式化最終形成了一個代數方程組。該方法在域上近似未知函數。然後，將對這些有限元建模的簡單方程式組合成一個對整個問題進行建模的較大方程式系統。然後，有限元素法通過最小化關聯的誤差函數，使用來自變異演算的變異方法來近似求解。 \n 優點： ﹙1﹚鄰近元素的材料性質不一定要相同。如此，能使這種疾法應用到由不同材料所組成的物體。 ﹙2﹚不規則形狀的邊界，能用直邊的元素作近似估計，或用曲線邊界作正確配合。 ﹙3﹚元素的大小可以改變。這種性質能視要，將元素格了擴大或縮小。﹙4﹚邊界條件，諸如不連續性的面負荷，用這種鞋法不會產生任何困鄞。能很容易解決混合邊界條件。 缺點： ﹙1﹚有限元素法的解法非常的龐雜，即使是一個小問題若用人工來計算仍是相當的複雜，所以相當需要電腦的輔助運作， \n 工作流程包括 （1）將問題的域劃分為子域的集合，每個子域由一組元素方程表示為原始問題，然後（2）系統地將所有元素方程組重組為用於最終計算的全域方程組。 在上面的第一步中，元素方程是簡化過的方程，可以局部地近似要研究的原始復雜方程組，其中原始方程通常是偏微分方程。為了求此方程式的近似解，通常將有限元素法作為伽遼金法的特例來處理。用數學語言來說，該過程是將殘差和加權函數取內積，並將該積分設為零。簡單來說，它是通過將試驗函數擬合到偏微分方程中來最小化近似誤差的過程。殘差是由試驗函數引起的誤差，權重函數是投影殘差的多項式逼近函數。該過程消除了偏微分方程中的所有空間導數，從而使偏微分方程局部近似為一組穩態問題的代數方程，或是一組用於瞬態問題的常微分方程。如果基礎偏微分方程是線性的，則元素方程也是線性的，反之亦然。穩態問題中出現的代數方程組，便利用數值線性代數方法求解，而瞬態問題中出現的常微分方程組則使用其他數值方法（例如歐拉方法或Runge-Kutta法）通過數值積分來求解。 \n 歷史 有限元法最初起源於土木工程和航空工程中的彈性和結構分析問題的研究。它的發展可以追溯到Alexander Hrennikoff（1941）和Richard Courant (1942)的工作。他們使用的方法有很大的差異，但是他們具有共同的部分：利用網格離散化將一個連續區域轉化為一族離散的子區域，通常叫做元.Hrennikoff的工作離散用類似于格子的網格離散區域; Courant的方法將區域分解為有限個三角形的子區域，用於求解來源於圓柱體轉矩問題的二階橢圓偏微分方程. Courant的貢獻推動了有限元的發展，繪製了早期偏微分方程的研究結果。 \n 有限元素方法的發展開始於五十年代中後期使用在機身框架和結構分析上，並於六十年代通過斯圖加特大學的John Argyris和柏克萊加州大學的Ray W. Clough在土木工程中的應用工作中積累經驗。 基於五十年代至六十年代大型水壩計算研究的實踐經驗，1965年，中國計算數學專家馮康發表了《基於變分原理的差分格式》一文，奠定了有限元計算方法的嚴格數學理論，為後世有限元計算方法的實際應用提供了理論保證。  (https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E5%85%83%E5%88%86%E6%9E%90 \n", 'tags': '', 'url': 'About FEM.html'}, {'title': '參考資料', 'text': '\n https://github.com/Range-Software/range3 \n https://dart.dev/articles/archive/numeric-computation \n https://pub.dev/packages/extended_math \n https://itnext.io/building-a-calculator-app-in-flutter-824254704fe6 \n https://github.com/mdecourse/flutter_demo_3d \n https://github.com/mdecourse/flutter_cube \n https://github.com/mdecourse/Flutter-OBJ-3D-Viewer \n https://mechanicalc.com/reference/finite-element-analysis \n https://github.com/liebeskind/feap \n https://github.com/mikolalysenko/femgl \n https://konstrct.com/index.html \n \n', 'tags': '', 'url': '參考資料.html'}, {'title': '動態網站', 'text': '設定步驟請參考: \n https://github.com/mdecourse/project2020-1/issues/4 \n CMSiMDE 執行所需模組 \n sudo pip3 install flask flask_cors bs4 lxml \n uwsgi 所需模組 \n sudo apt install uwsgi uwsgi-plugin-python3 \n sudo pip3 install uwsgi \n /etc/nginx/sites-available/default 附加 server 設定  \n server {\n \n    listen 9443 ssl;\n    listen [::]:9443 ssl;\n \n    # 指定 static 所在位置\n    location /static {\n\talias /home/yen/cad1_site/cmsimde/static/;\n    }\n \n    location / {\n\t# 導入 uwsgi_params 設定參數\n\tinclude uwsgi_params;\n\t# 根目錄設為近端的 8080 port \n\tuwsgi_pass  127.0.0.1:8080;\n    }\n \n    ssl_certificate /home/yen/localhost.crt;\n    ssl_certificate_key /home/yen/localhost.key;\n    #ssl_certificate /etc/letsencrypt/live/cad1.kmol.info/fullchain.pem;\n    #ssl_certificate_key /etc/letsencrypt/live/cad1.kmol.info/privkey.pem;\n    ssl_session_timeout 5m;\n    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;\n    ssl_ciphers "HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES";\n    ssl_prefer_server_ciphers on;\n    try_files $uri $uri/ =404;\n} \n 建立 self-signed key sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout localhost.key -out localhost.crt /home/yen/uwsgi_ini/uwsgi.ini \n [uwsgi]\nsocket = :8080\nuid = yen\ngid = yen\nplugins-dir = /usr/lib/uwsgi/plugins/\nplugin = python3\nmaster = true\nprocess = 4\nthreads = 2\nchdir = /home/yen/cad1_site/cmsimde\nwsgi-file = /home/yen/cad1_site/cmsimde/wsgi.py \n uwsgi emperor 手動測試 \n /usr/bin/uwsgi --emperor /home/yen/uwsgi_ini 防火牆設定 \n 先暫時關閉 ufw \n ufw disable \n 允許設計系 IP v6 網段連線 9443 port \n ufw allow from 2001:288:6004:17::/32 to any port 9443 \n 其他網段主機一律]不准連線 \n ufw deny 9443 \n 重新開啟 ufw 防火牆 \n ufw enable \n /etc/systemd/system 目錄中建立 cmsimde.service 檔案 \n \n [Unit]\nDescription=uWSGI to serve CMSiMDE \nAfter=network.target\n \n[Service]\nUser=yen\nGroup=yen\nWorkingDirectory=/home/yen/uwsgi_ini\nExecStart=/usr/bin/uwsgi --emperor /home/yen/uwsgi_ini\n \n[Install]\nWantedBy=multi-user.target \n \n 接著將 cmsimde 服務設為隨系統開機啟動: \n sudo systemctl enable cmsimde\n \n 若要取消 cmsimde 服務隨系統開機啟動: \n sudo systemctl disable cmsimde\n \n 手動啟動 cmsimde.service 服務 \n sudo systemctl start cmsimde\n \n 手動停止 cmsimde.service 服務 \n sudo systemctl stop cmsimde \n \n', 'tags': '', 'url': '動態網站.html'}, {'title': '數位簽章', 'text': 'https://letsencrypt.org/ \n https://certbot.eff.org/lets-encrypt/ubuntufocal-nginx \xa0 \n sudo apt-get update\nsudo apt-get install software-properties-common\nsudo add-apt-repository universe\nsudo apt-get update\n\nsudo apt-get install certbot python3-certbot-nginx\n\nsudo certbot certonly --nginx\n\nsudo certbot renew --dry-run \n \n', 'tags': '', 'url': '數位簽章.html'}, {'title': 'test_latex', 'text': "$$\\frac{1}{x^2-1}$$ \n 偏微分方程式: \n $$f(x) = \\int_{0}^{x} f'(t)dt$$ \n 一維: \n $\\mathrm{P1} :\\left\\{\\begin{matrix}   u''(x)=f(x)\\mathrm{in} (0,1), \\\\   u(0)=u(1)=0, \\end{matrix}\\right.$ \n 二維: \n $\\mathrm{P2}:\\begin{cases} u {\\tiny xx} (x,y)+u{\\tiny yy}(x,y) = f(x,y)&\\mathrm{in} \\ \\Omega\\\\ u=0&\\mathrm{on}\xa0\xa0 \xa0\\ \\partial\\Omega \\end{cases}$ \n \n", 'tags': '', 'url': 'test_latex.html'}, {'title': '專題流程', 'text': '討論區:  https://github.com/mdecourse/4072pj2/discussions \n Finite Element Analysis (有限元素分析) 是一種 數值分析方法 可用來 解系統的微分方程式 , 主要是利用 數學近似 的方法模擬 真實物理系統在各種受力或環境邊界條件下的反應情形 . 方法架構是利用 簡單且相互作用的元素單元 互相結合運算下, 就可以利用 有限數量 的未知量逼近 無限 未知量的真實系統. \n Finite Element Method \n 解微分方程式的其他常見方法: \n finite difference method \n boundary element method \n finite volume method \n \n', 'tags': '', 'url': '專題流程.html'}, {'title': '1DFEM', 'text': '先從了解 1D boundary value differential equation 的數值分析解法開始 \n 參考書: \n https://link.springer.com/book/10.1007/978-3-642-33287-6\xa0 \n https://hplgit.github.io/fem-book/doc/pub/book/pdf/fem-book-4print.pdf\xa0 \n 程式碼: \n https://people.sc.fsu.edu/~jburkardt/py_src/fem1d/fem1d.html\xa0 \n 1d_fem_linear_c_py_ex.7z \n FEM1D , a Python program which applies the finite element method (FEM) to a 1D linear two point boundary value problem (BVP), using piecewise linear basis functions. \n The BVP to be solved is: \n         -u\'\' = x * ( x + 3 ) * exp ( x )  over the interval 0 < x < 1\n        u(0) = 0.0\n        u(1) = 0.0 \n The exact solution is: \n         u(x) = x * ( 1 - x ) * exp ( x ) \n A version of the finite element method is used. Six equally spaced nodes are defined, from 0.0 to 1.0, dividing the interval into 5 elements. At node I, we associate a "hat" function, or piecewise linear basis function, PSI(I)(X), which has the value 1 at that node, is 0 at all other nodes. \n We look for an approximate solution to our problem of the form \n         UH(X) = sum ( 1 <= I <= 6 ) C(I) * PSI(I,X) \n so that now the problem becomes the determination of the unknown coefficients C. \n We take the original BVP, multiply by test function PSI(J,X), integrate over the region, and apply integration by parts, to obtain a linear system of the form \n         A * C = F \n We modify the first and last rows of the linear system to enforce the boundary conditions, then solve to determine the values of C. \n Licensing: \n The computer code and data files described and made available on this web page are distributed under \xa0 the GNU LGPL license. \n Languages: \n FEM1D \xa0 is available in \xa0 a C version \xa0 and \xa0 a C++ version \xa0 and \xa0 a FORTRAN90 version \xa0 and \xa0 a MATLAB version \xa0 and \xa0 a Python version. \n Related Data and Programs: \n FEM1D_BVP_LINEAR , a Python program which applies the finite element method (FEM), with piecewise linear elements, to a two point boundary value problem (BVP) in one spatial dimension, and compares the computed and exact solutions with the L2 and seminorm errors. \n FD1D_HEAT_EXPLICIT , a Python library which uses the finite difference method (FDM) and explicit time stepping to solve the time dependent heat equation in 1D. \n FEM1D , a data directory which contains examples of 1D FEM files, three text files that describe a 1D finite element model; \n FEM1D_BVP_QUADRATIC , a Python program which applies the finite element method (FEM), with piecewise quadratic elements, to a two point boundary value problem (BVP) in one spatial dimension. \n FEM1D_CLASSES , a Python library which defines classes useful for solving a boundary value problem (BVP) of the form u\'\'+2u\'+u=f in 1 spatial dimension, using the finite element method (FEM), by Mike Sussman. \n Reference: \n \n \n Gilbert Strang, George Fix, An Analysis of the Finite Element Method, Cambridge, 1973, ISBN: 096140888X, LC: TA335.S77. \n \n \n Source Code: \n \n \n fem1d.py , the source code. \n fem1d.sh , commands to compile the source code. \n fem1d.txt , the output file. \n \n \n \n \n fem1d.png , a plot comparing the computed and exact solutions. \n \n', 'tags': '', 'url': '1DFEM.html'}, {'title': 'Matlab', 'text': 'http://www.spacar.nl/wiki/doku.php?id=start \n spacar_man2009.pdf \n protmodslides2015.pdf \n protmod2014.pdf \n \n https://github.com/lyc102/ifem \n https://www.math.uci.edu/~chenlong/programming.html \n \n https://github.com/JWock82/PyNite \n https://www.eng-tips.com/viewthread.cfm?qid=474433 \n', 'tags': '', 'url': 'Matlab.html'}, {'title': 'Abaqus 流程', 'text': '利用  https://www.standoutvitae.com/article/gautampuri0161663/abaqus-basics/  中的範例分別在 Abaqus, Range3, Ansys, Comsol, NGSolve 中進行分析比較其結果. \n 列出有限元素分析法的分析原理並利用上述範例延伸至摺疊椅的強度分析. \n 27011_37 \n https://www.standoutvitae.com/article/gautampuri050534/abaqus-fea-tutorial-series/ \n http://130.149.89.49:2080/v6.14/pdf_books/index.pdf \n The Secondary Development of ABAQUS by using Pythonand the Application of the Advanced GA.pdf \n ABAQUS_python_tutorial.pdf \n Abaqus_SCRIPT_USER.pdf \n learnabaqusscriptinonehour.pdf \n Python Scripts for Abaqus.pdf \n abaqus_scripting-summary.pdf \n lsight_tip1805_102.pdf \n Finite ElementModelingwith Abaqusand Pythonfor Thermal andStress Analysis.pdf \n A Pragmatic Introduction to theFinite Element Methodfor Thermal and Stress Analysis.pdf \n http://hogwarts.ucsd.edu/~pkrysl/faesor/#downloads \n DimensionalModelReductioninNon-linearFiniteElementDynamicsofSolidsandStructures.pdf \n 軌道絕緣接頭之應力數值分析.pdf \n Abaqus 6.14 EXAMPLES_1.pdf \n Abaqus 6.14 EXAMPLES_2.pdf', 'tags': '', 'url': 'Abaqus 流程.html'}, {'title': 'FEM 應用', 'text': 'fem_ref.7z \n \n \n', 'tags': '', 'url': 'FEM 應用.html'}, {'title': '專利搜尋', 'text': 'https://github.com/daneads/pypatent \xa0 \n https://github.com/wenyalintw/Google-Patents-Scraper \xa0 \n https://github.com/helmersl/patent_similarity_search \xa0 \n https://github.com/ryanlstevens/google_patent_scraper \xa0 \n https://commercedataservice.github.io/tutorial_pto/ \xa0 \n https://en.wikipedia.org/wiki/User:Jrincayc/Patent_utils \xa0 \n http://www.ipstreet.com/ \xa0 \n', 'tags': '', 'url': '專利搜尋.html'}, {'title': '參數式 CAD', 'text': 'Solvesapce: 自行編譯, 可修改功能, Pyslvs-UI 應用核心 \n Onshape: 雲端系統 \n NX12: 高端參數 CAD \n Solidworks 2017: 最普遍使用參數 CAE \n', 'tags': '', 'url': '參數式 CAD.html'}, {'title': 'Solvespace', 'text': '可以直接從\xa0 https://github.com/Symbian9/SolveSpace-Daily-Engineering/blob/master/README.md#solvespace-3x-slvs  下載, 或自行編譯. \n \n \n 編譯 Solvespace 的步驟, 需要先下載能夠 編譯 C++17 原始碼的可攜系統 \n \n \n 接著啟動可攜系統後, 以 \n \n \n git clone --recurse-submodules \xa0 https://github.com/solvespace/solvespace.git \n 取下最新的程式碼, 以及子模組中的所有原始碼. \n \n \n 接著要確定 portablegit\\bin\\ 與 Y:\\msys64\\usr\\bin\\ 目錄中的 sh.exe 都改名為 sh_rename_for_compiling_solvespace.exe \n \n \n 由於上述可攜系統已經安裝 Msys2 與 CMAKE, 因此只需要在命令列中進入 solvespace 原始碼目錄, 以 mkdir 建立 build 目錄, 然後 cd build 後, 執行: \n \n \n cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release \n 以便建立所需的 Makefile \n \n 然後再利用 \n \n make \n 完成所有程式碼的編譯. \n \n 最後 solvespace.exe 已經位於 solvespace/build/bin 目錄中, 只要再從 Y:\\msys64\\mingw64\\bin\\libwinpthread-1.dll 複製 dll 檔案放入 bin 目錄, 就可以啟動 solvespace.exe 進行參數零件, 轉出 stl 檔案 (為 binary stl 格式) 後, 就可以導入 Range3 進行後續的 CAE 分析. \n \n from https://drive.google.com/file/d/1AaOdJdZPNiD3YE5kgNcIrLK7ic0qsme1/view?usp=sharing get wcm2020_project \n about cmake: \xa0 https://cmake.org/ \n about msys2: \xa0 https://www.msys2.org/ \n about solvespace: \xa0 https://github.com/solvespace/solvespace \n install cmake \n pacman -S mingw-w64-x86_64-cmake\n \n rename Y:\\msys64\\usr\\bin\\sh.exe to sh_renamed_for_compiling_solvespace.exe \n build solvespace.exe \n use mingw64.exe \n cd /y/tmp/cad_ex\n\ncd solvespace\nmkdir build\ncd build\ncmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release\nmake\n \n need Y:\\msys64\\mingw64\\bin\\libwinpthread-1.dll to execute solvespace.exe \n \n 根據上述步驟完成的編譯專案檔案位於: \n project2020-2_compile_solvespace.7z \n', 'tags': '', 'url': 'Solvespace.html'}, {'title': 'FEM\xa0theory', 'text': '1 dimension\xa0 \n 2 dimension \n mathematics symbol \n \n \n \n \n 符號 \n \n 名稱 \n 定義 \n 舉例 \n \n \n 讀法 \n \n \n 數學領域 \n \n \n \n = \n \n 等號 \n 表示 和 是相同的東西或其值相等。 \n \n \n \n 等於 \n \n \n 所有領域 \n \n \n \n ≠ \n \n 不等號 \n 表示 和 不是相同的東西或其值不相等。 \n \n \n \n 不等於 \n \n \n 所有領域 \n \n \n \n < > \n \n 嚴格不等號 \n 表示 小於 。 表示 大於 。 \n \n \n \n 小於 ， 大於 \n \n \n 序理論 \n \n \n \n ≤ ≥ \n \n 不等號 \n 表示 小於或等於 。 表示 大於或等於 。 \n ； ； \n \n \n 小於等於 ， 大於等於 \n \n \n 序理論 \n \n \n \n + \n \n 加號 \n 表示 3 加 3。 \n \n \n \n 加 \n \n \n 算術 \n \n \n \n − \n \n 減號 \n 表示 6 減 3 或 6 被 3 減。 \n \n \n \n 減 \n \n \n 算術 \n \n \n 負號 \n − 5 表示 5 的負數。 \n \n \n \n 負 \n \n \n 算術 \n \n \n 補集 \n 表示包含所有屬於 但不屬於 的元素的集合。 \n \n \n \n 減 \n \n \n 集合論 \n \n \n \n × \n \n 乘號 \n 表示 2 乘以 3。 \n \n \n \n 乘以 \n \n \n 算術 \n \n \n 直積 \n 表示所有第一個元素屬於 ，第二個元素屬於 的 有序對 的集合。 \n \n \n \n … 和…的直積 \n \n \n 集合論 \n \n \n 向量積 \n 表示 向量 和 的向量積。 \n \n \n \n 向量積 \n \n \n 向量代數 \n \n \n \n ÷ / \n \n 除號 \n 或 表示 6 除以 3 或 3 除 6 或 6 被 3 除。 \n \n \n \n 除以 \n \n \n 算術 \n \n \n \n \n \n 根號 \n 表示其平方為 的正數。 \n \n \n \n …的平方根 \n \n \n 實數 \n \n \n 複根號 \n 若用 極坐標 表示複數 （滿足 ），則 。 \n \n \n \n …的平方根 \n \n \n 複數 \n \n \n \n |\xa0| \n \n 絕對值 \n 表示 實數軸 （或 複平面 ）上 \xa0 x \xa0 和 \xa0 0 \xa0 的距離。 \n , \xa0 , \xa0 , \xa0 \n \n \n …的絕對值 \n \n \n 數 \n \n \n \n ! \n \n 階乘 \n 表示連乘積 。 \n \n \n \n …的階乘 \n \n \n 組合論 \n \n \n \n ~ \n \n 機率分布 \n 表示 隨機變數 機率分布為 。 \n ： 標準常態分布 \n \n \n 滿足分布 \n \n \n 統計學 \n \n \n 相似 \n 「圖形A~圖形B」表示兩個圖形形狀完全相同（但大小不一定一樣） \n 當 ，則 , \xa0 , \xa0 ，但是不代表 \xa0 , \xa0 , \xa0 \n \n \n 相似於，…與…相似 \n \n \n 幾何 \n \n \n \n ⇒ → ⊃ \n \n 實質蘊涵 \n 表示 真則 也真； 假則 不定。 可能和 一樣，或者有下面將提到的 函數 的意思。 可能和 一樣，或者有下面將提到的 父集 的意思。 \n 為真，但 一般情況下為假（因為 可以是 ）。 \n \n \n 推出，若…則 … \n \n \n 命題邏輯 \n \n \n \n ⇔ ↔ \n \n 實質等價 \n 表示 真則 真， 假則 假。 \n \n \n \n 若且唯若（若且唯若） \n \n \n 命題邏輯 \n \n \n \n ¬ ˜ \n \n 邏輯非 \n 命題 為真若且唯若 為假。 將一條斜線穿過一個符號相當於將 " " 放在該符號前面。 \n \n \n \n \n \n 非，不 \n \n \n 命題邏輯 \n \n \n \n ∧ \n \n 邏輯與 或 交運算 \n 若 為真且 為真，則命題 為真；否則為假。 \n ，當 是 自然數 \n \n \n 與 \n \n \n 命題邏輯 ， 格理論 \n \n \n \n ∨ \n \n 邏輯或 或 併運算 \n 若 或 （或都）為真，則命題 為真；若兩者都假則命題為假。 \n ，當 是 自然數 \n \n \n 或 \n \n \n 命題邏輯 ， 格理論 \n \n \n \n ⊕ \n \n ⊻ \n \n 互斥或 \n 若 和 剛好有一個為真，則命題 為真。 的意義相同。 \n 恆為真， 恆為假。 \n \n \n 互斥或 \n \n \n 命題邏輯 ， 布爾代數 \n \n \n \n ∀ \n \n 全稱量詞 \n 表示 對於所有 為真。 \n \n \n \n 對所有；對任意；對任一 \n \n \n 謂詞邏輯 \n \n \n \n ∃ \n \n 存在量詞 \n 表示存在至少一個 使得 為真。 \n 為偶數 \n \n \n 存在 \n \n \n 謂詞邏輯 \n \n \n \n ∃ ! \n \n 唯一量詞 \n 表示有且僅有一個 \xa0 x \xa0 使得 \xa0 P ( x ) 為真。 \n \n \n \n 存在唯一 \n \n \n 謂詞邏輯 \n \n \n \n := ≡ : ⇔ \n \n 定義 \n 或 表示 定義為 的一個名字（注意： 也可表示其它意思，例如 恆等於 ）。 表示 定義為 的邏輯等價。 \n \n \n \n 定義為 \n \n \n 所有領域 \n \n \n \n { , } \n \n 集合 括號 \n 表示 組成的集合。 \n \n \n \n …的集合 \n \n \n 集合論 \n \n \n \n {\xa0: } { | } \n \n 集合構造記號 \n 表示所有滿足 的 的集合。 和 的意義相同。 \n \n \n \n 滿足…的集合 \n \n \n 集合論 \n \n \n \n ∅ {} \n \n 空集合 \n 表示沒有元素的集合。 的意義相同。 \n \n \n \n 空集合 \n \n \n 集合論 \n \n \n \n ∈ ∉ \n \n 元素 歸屬性質 \n 表示 屬於集合 \n 表示 不屬於 。 \n \n \n \n \n 屬於；不屬於 \n \n \n 所有領域 \n \n \n \n ⊆ ⊂ \n \n ⫋ \n \n 子集 \n 表示 的所有元素屬於 。 表示 但 。\n （有的地方記作 ） \n \n \n \n \n \n \n \n …的子集 \n \n \n 集合論 \n \n \n \n ⊇ ⊃ \n ⫌ \n \n \n 父集 \n 表示 的所有元素屬於 。 表示 但 。\n （有的地方記作 ） \n \n \n \n \n \n \n \n …的父集 \n \n \n 集合論 \n \n \n \n ∪ \n \n 並集 (聯集) \n 表示包含所有 和 的元素但不包含任何其他元素的集合。 \n \n \n \n …和…的並集 \n \n \n 集合論 \n \n \n \n ∩ \n \n 交集 \n 表示包含所有同時屬於 和 的元素的集合。 \n \n \n \n …和…的交集 \n \n \n 集合論 \n \n \n \n \\\n \n \n \n 補集 \n 表示所有屬於 但不屬於 的元素的集合。\n （有的地方記作 {\\displaystyle \\complement _{A}B} ） \n \n \n \n \n \n \n 減；除去 \n \n \n 集合論 \n \n \n \n ( ) \n \n 函數 應用 \n 表示 在 的值。 \n ，則 。 \n \n \n \n \n \n 集合論 \n \n \n 優先組合 \n 先執行括號內的運算。 \n \n \n \n \n \n \n \n \n 所有領域 \n \n \n \n ƒ \xa0: X → Y \n \n 函數 箭頭 \n 表示 從集合 映射到集合 。 \n 設 定義為 。 \n \n \n 從…到… \n \n \n 集合論 \n \n \n \n o \n \n 複合函數 \n 是一個函數，使得 。 \n 若 且 ，則 \xa0 。 \n \n \n 複合 \n \n \n 集合論 \n \n \n \n N \n \n ℕ \n \n 自然數 \n 表示 ，另一定義參見自然數條目。 \n \n \n \n N \n \n \n 數 \n \n \n \n Z \n \n ℤ \n \n 整數 \n 表示 。 \n \n \n \n Z \n \n \n 數 \n \n \n \n Q \n \n ℚ \n \n 有理數 \n 表示 。 \n \n \n \n Q \n \n \n 數 \n \n \n \n R \n \n ℝ \n \n 實數 \n 表示 極限存在 。 \n \n \n \n R \n \n \n 數 \n \n \n \n C \n \n ℂ \n \n 複數 \n 表示 。 \n \n \n \n C \n \n \n 數 \n \n \n \n ∞ \n \n 無窮 \n 是 擴展的實數軸 上大於任何實數的數；通常出現在 極限 中。 \n \n \n \n 無窮 \n \n \n 數 \n \n \n \n π \n \n 圓周率 \n 表示 圓 周長和直徑之比。 \n 是半徑為 的圓的面積 \n \n \n pi \n \n \n 幾何 \n \n \n \n ||\xa0|| \n \n 範數 \n 是 賦範向量空間 元素 {\\displaystyle x} 的範數。 \n \n \n \n …的範數；…的長度 \n \n \n 線性代數 \n \n \n \n ∑ \n \n 求和 \n 表示 . \n \n \n \n 從…到…的和 \n \n \n 算術 \n \n \n \n ∏ \n \n 求積 \n 表示 . \n \n \n \n 從…到…的積 \n \n \n 算術 \n \n \n 直積 \n 表示所有 \xa0 (n+1)-元組 \xa0 ( )。 \n \n \n \n …的直積 \n \n \n 集合論 \n \n \n \n \' \n \n 導數 \n 函數 在 點的導數，也就是，那裡的 切線 斜率 。 \n 若 , 則 \n \n \n … 撇; …的導數 \n \n \n 微積分 \n \n \n \n ∫ \n \n 不定積分 \xa0 或 \xa0 反導數 \n 表示導數為 的函數. \n \n \n \n …的不定積分; …的反導數 \n \n \n 微積分 \n \n \n 定積分 \n 表示 x -軸和 在 和 之間的 函數圖像 所夾成的帶符號 面積 。 \n \n \n \n 從…到…以…為變數的積分 \n \n \n 微積分 \n \n \n \n ∇ \n \n 梯度 \n 偏導數組成的向量 \n 若 則 \n \n \n …的( del 或 nabla 或 梯度 ) \n \n \n 微積分 \n \n \n \n ∂ \n \n 偏導數 \n 設有 是 的對於 的當其他變數保持不變時的導數. \n 若 , 則 \n \n \n …的偏導數 \n \n \n 微積分 \n \n \n 邊界 \n 表示 的邊界 \n \n \n \n …的邊界 \n \n \n 拓撲 \n \n \n 次數 \n 表示 的次數（也記作 ） \n \n \n \n …的次數 \n \n \n 多項式 \n \n \n \n ⊥ \n \n 垂直 \n 表示 垂直於 ；更一般的 正交於 . \n 若 和 則 . \n \n \n 垂直於 \n \n \n 幾何 \n \n \n 底元素 \n 表示 是最小的元素. \n \n \n \n 底元素 \n \n \n 格理論 \n \n \n \n ⊧ \n \n 蘊涵 \n 表示 蘊涵 ，在 成立的每個 模型 中， 也成立. \n \n \n \n 蘊涵； \n \n \n 模型論 \n \n \n \n ⊢ \n \n 推導 \n 表示 由 導出. \n \n \n \n 從…導出 \n \n \n 命題邏輯 , \xa0 謂詞邏輯 \n \n \n \n ◅ \n \n 正規子群 \n 表示 是 的正規子群. \n \n \n \n 是…的正規子群 \n \n \n 群論 \n \n \n \n / \n \n 商群 \n 表示 模 其子群 的商群. \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n 模 \n \n \n 群論 \n \n \n \n ≈ \n \n 同構 \n 表示 同構於 。 \n , 其中 是 四元數群 \xa0 是 \xa0 克萊因四群 . \n \n \n 同構於 \n \n \n 群論 \n \n \n \n ∝ \n \n 正比 \n 表示 正比於 。 \n 若 ，則 \n \n \n 正比於 \n \n \n 所有領域 \n \n \n \n \n https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7%E8%A1%A8 \n \n 下載專門用於 Range3 與 NGSolve 的可攜套件  (使用 Python 3.7.9) \n \n Introduction to NumericalMethods for VariationalProblems.pdf \n PracticeProblemsforFiniteElementMethod.pdf \n FEA Theory.pdf \n Intro to FEM.pdf \n Finite element procedures.pdf  ( source ) \n Solution Manual.pdf  ( source ) \n Examples solving an ODE using finite elements method. Mathematica and Matlabimplementation and animation.pdf \n weighted residual methods.pdf \n 加權殘值法(Weighted Residual Methods), 是一種用於求解微分方程近似解的數值方法. 加權殘值法具有原理統一, 不依賴變分,誤差可知等優點, 常應用於解算流體力學, 固體力學等問題. Weighted residual method involves two major steps.  In the first step, an approximate solution based on the general behavior of the  dependent variable is assumed. The assumed solution is often selected so as to  satisfy the boundary conditions for unknown dependent variable.  This assumed solution is then substituted in the differential equation. Since the  assumed solution is only approximate, it does not in general satisfy the differential  equation and hence results in an error or what we call aresidual.  The residual is then made to vanish in some average sense over the entire solution domain  to produce a system of algebraic equations.  The second step is to solve the system of equations resulting from the first step  subject to the prescribed boundary condition to yield the approximate solution sought. https://github.com/spectralDNS/shenfun   \n Galerkin Method:  https://en.wikipedia.org/wiki/Galerkin_method \n https://en.wikipedia.org/wiki/Eddy-current_sensor \n 2013_sliding interfaces for eddy current simulations.pdf \n Lect16-FEM-Example-BasicSteps.pdf \xa0\xa0 \xa0 Lectures onThe Finite Element Method.pdf \xa0\xa0 \xa0 Topics In Finite Element Solution ofElliptic Problems.pdf \xa0\xa0 \xa0 PracticeProblemsforFiniteElementMethod.pdf \n \n mesh 網格化: \n tetgen_manual.pdf \n tetgen.org \xa0( https://github.com/ufz/tetgen ) \n Python interface to tetgen:\xa0 https://github.com/pyvista/tetgen \n Three Dimensional Boundary Conforming Delaunay Mesh Generation  - Ph.D. dissertation \n', 'tags': '', 'url': 'FEM\xa0theory.html'}, {'title': '1 Dimension', 'text': '1.1.1分段多項式空間 \n 1.1.1 線性多項式空間 \n 假設$I=\\left[x_{0}, x_{1}\\right]$，$P_{1}(I)$表示成空間向量線性方程式，我們可得到下列定義式 \n $P_{1}(I)=\\left\\{v: v(x)=c_{0}+c_{1} x, x \\in I, c_{0}, c_{1} \\in \\mathbb{R}\\right\\}$ \n 由上面定義式可得知 $P_{1}(I)$ 在$v(x)=c_{0}+c_{1} x$中包含了所有形式的函數，也就是說 $P_{1}(I)$ 是一個單項式$\\{1, x\\}$，其集合位於1~X之間。在 $v(x)=c_{0}+c_{1} x$ 中$v$被$1 \\times C_{0}+1 \\times C_{0} x$明確定義，這就是所謂的線性組合係數，由此可知v有兩個自由度且由c0、c1掌握。 \n 對於v來說其自由度不僅僅只有 $c_{0}$、 $c_{1}$ ，根據線性定義一條線由兩點連線形成，由此可得知v的自由度有許多組，特別的是V的值$\\alpha_{0}=v\\left(x_{0}\\right)$、$\\alpha_{1}=v\\left(x_{1}\\right)$可藉由$I$的$x_{0}$、$x_{1}$求得 \n 為了證明上述理論，我們假設已知$\\alpha_{0}=v\\left(x_{0}\\right)$ 、$\\alpha_{1}=v\\left(x_{1}\\right)$ \n $\\left[\\begin{array}{ll}1 & x_{0} \\\\ 1 & x_{1}\\end{array}\\right]\\left[\\begin{array}{l}c_{0} \\\\ c_{1}\\end{array}\\right]=\\left[\\begin{array}{l}\\alpha_{0} \\\\ \\alpha_{1}\\end{array}\\right]$ \n \n 1.3 $L^2$-投影 \n \n 插值是逼近連續函數的一種簡單方法，但是還有其他方式。本節將研究正交或$ L^2$\xa0 - 投影。 $L^2 $ - 投影的平均近似值可以說不錯，但與插值相反，插值在節點上是精確的。而且與插值相比， $L^2$\xa0 - 投影不需要我們尋求近似的函數保持連續或具有明確定義的節點值。 \n 1.3.1定義 \n 給定一個函數 $f\\in L^2(I) 的 L^2$投影 $P{\\scriptsize {\\tiny h} } f\\in V{\\tiny h} $定義為 \xa0 $\\int_{I}\\left(f-P_{h} f\\right) v d x=0, \\quad \\forall v \\in V_{h}$ \xa0  ( 1.36) \xa0 圖1.5 函數$f$及其在空間 $V{\\tiny h} $上的 $L^{2}$ - 投影 $P{\\tiny h} f $的圖示 \xa0 \n \n 圖1.6\xa0 $f(x)=2 x \\sin (2 \\pi x)+3$ 和它在$$L^{2}$$- 投影 $P_{h} f$ 上的均勻網格$ I=[0,1] $有六個節點, $i=1,2,...,6$ \xa0 \n \n 與投影到$\\mathbb{R} ^n$ 的子空間類似，（1.34）定義$f$的投影到$ V{\\tiny h}$ 上，因為差$ f - P{\\tiny h} f $必須與所有函數正交$ v$在 $V{\\tiny h} f$中。如圖1.5所示。 稍後我們將看到，$P_{h} f$ 是是 $min_{{\\scriptsize v } \\in V {\\tiny h} } \\left \\| f-v \\right \\| _{L^2(I)} $的極小值因此我們說它在最小二乘意義上近似於$f$。實際上， $P_{h} f$ 是測量誤差$f-P_{h} f$時對$f$的最佳近似 $L^{2}$ 範數中。   在圖1.6中，我們顯示了$f(x)=2 x \\sin (2 \\pi x)+3$的$L^{2}$ -投影。 與用於顯示連續分段線性插值的網格相同,圖1.4中的$f$。比較這兩個近似值是有益的，因為它突出了它們的不同特徵。插值$f$精確地逼近$f$在節點處，而$L^2$投影 $P{\\tiny h} f$ 平均接近 $f $。這樣做因此，$P_{h} f$ 超過或低於枝條的局部最大值和最小值是很常見的。$f$分別。而且，內插和$L^2$-投影都存在困難具有近似快速振盪或不連續的函數，除非該節點位置已適當調整。 \xa0 \n \n 1.3.2 線性方程組的推導 \xa0 \n \n 為了實際計算 $L^{2}$ - 投影$P_{h} f$ ，我們首先要注意定義（1.36）等同於 \xa0 $\\int_{I}\\left(f-P_{h} f\\right) \\varphi_{i} d x=0, \\quad i=0,1, \\ldots, n$\xa0 \xa0\xa0 ( 1.37) \xa0 $\\varphi_{i}, i=0,1, \\ldots, n$， 是帽子函數。這是事實的結果，如果 （1.36）成立於v的帽子函數的人，那麼它也滿足對於v帽子函數的線性組合。 相反，由於$V_{h}$ 中的任何函數v為正是這樣的帽子函數的線性組合 ，（1.37）意味（1.36）。 然後，由於$P_{h} f$ 屬於$V_{h}$ ， 因此可以寫成線性組合 \xa0 $P_{h} f=\\sum_{j=0}^{n} \\xi_{j} \\varphi_{j}$\xa0\xa0\xa0( 1.38) \xa0 其中$\\xi _{j},j=0,1,...,n $,是要確定的$n + 1$個未知係數。插入（1.38）變成（1.37）我們得到 \xa0 $\\int_{I} f \\varphi_{i} d x=\\int_{I}\\left(\\sum_{j=0}^{n} \\xi_{j} \\varphi_{j}\\right) \\varphi_{i} d x$ \xa0( 1.39) \xa0 $b_{i}=\\int_{I} f \\varphi_{i} d x, \\quad i=0,1, \\ldots, n$ ( 1.40) \xa0 進一步介紹符號 \xa0 $M_{i j}=\\int_{I} \\varphi_{j} \\varphi_{i} d x, \\quad i, j=0,1, \\ldots, n$ ( 1.41) \xa0 $b_{i}=\\int_{I} f \\varphi_{i} d x, \\quad i=0,1, \\ldots, n$ ( 1.42) \xa0 $b_{i}=\\sum_{j=0}^{n} M_{i j} \\xi_{j}, \\quad i=0,1, \\ldots, n$ ( 1.43) 對於$n + 1$個未知係數$\\xi _{j},j=0,1,...,n$\xa0 ，它是$ (n + 1)\\times (n + 1) $線性系統。以矩陣形式，我們這樣寫 $M \\xi=b$ ( 1.44) \xa0 其中$(n+1) \\times(n+1)$ 矩陣$M$和$(n+1) \\times 1$ 向量b, 分別 由（1.41）和（1.42）定義。 因此，我們得出結論，係數$\\xi_{j}, j=0,1, \\ldots, n$ 在方法（1.38 \xa0 ) \xa0 中滿足一個正方形的線性系統，其必須以獲得$L^{2}$ -投影$P_{h} f$ 來解決 。 \xa0 由於歷史原因，我們將$M$稱為質量矩陣，將$b$稱為載荷向量。 \n 1.3.3計算$L^2$-投影的基本算法 \n \n 以下算法總結了計算$L^2$-投影的基本步驟 $P{\\tiny h}f$：  算法:計算$L^2$投影的基本算法  1:在間隔$I$上創建具有$n$個元素的網格，並定義相應的間隔連續分段線性函數$V{\\tiny h}$ 。  2:計算$(n + 1)\\times (n + 1)$矩陣$M$和$(n + 1)\\times $1個向量$b$  $M_{ij} =\\int_{I}^{} \\varphi _{j} \\varphi _{i} dx,\xa0 bi=\\int_{I}^{} f\\varphi _{i} dx$\xa0 (1.45)  3:求解線性系統  $M\\xi =b$\xa0 (1.46)  4:設置 $P{\\tiny h} f=\\sum_{j=0}^{n} \\xi _{j} \\varphi _{j}$\xa0 (1.47)  \xa0 \n 1.3.4先驗誤差估計 \n \n 我們希望得出誤差 $f-P{\\tiny h}f$ 的界限。下一個定理給出得出此類誤差估計的關鍵結果。這就是所謂的最佳近似結果。  定理1.1。在$L^2$ -投影 $P{\\tiny h}f $，由下式定義（1.36），可以滿足最好的大概- 模擬結果 $\\left \\| f-P{\\tiny h} f \\right \\| _{L^2(I)} \\le \\left \\| F-V \\right \\| _{L^2(I)} , \\forall V\\in V{\\tiny h} $\xa0 (1.48) 證明。 使用$L^2$-範數的定義並寫出$f-P{\\tiny h} f=f-v+v-P{\\tiny h} f$，通過$v$在$V{\\tiny h}$ 中的任意函數 $\\left \\| f-P{\\tiny h} f \\right \\| _{L^2(I)}^{2} =\\int_{I}^{} \\left ( f-P{\\tiny h} f \\right )\\left ( f-v+v-P{\\tiny h} f \\right ) dx$\xa0 (1.49)  $\\int_{I}^{} \\left ( f-P{\\tiny h} f \\right )\\left ( f-v \\right ) dx+\\int_{I}^{} \\left ( f-P{\\tiny h} f \\right )\\left (\xa0 v-P{\\tiny h} f \\right ) dx$\xa0 (1.50)  $\\int_{I}^{} \\left ( f-P{\\tiny h} f \\right )\\left ( f-v \\right ) dx$\xa0 (1.51)  $\\le \\left \\| f-P{\\tiny h} f \\right \\| _{L^2(I)} \\left \\| f-v \\right \\| _{L^2(I)}$\xa0 (1.52)  在這我們使用$L^2$投影的定義來得出結論  $\\int_{I}^{} \\left ( f-P{\\tiny h} f \\right )\\left ( v-P{\\tiny h} f \\right ) dx\xa0 =0$\xa0 \xa0 \xa0 (1.53)  由於$ v-P{\\tiny h} f\\in V{\\tiny h}$ 。除以$\\left \\| f-P{\\tiny h} f \\right \\| _{L^2(I)} $ 證明結論。這表明在測量時， $P{\\tiny h} f $是$V_{h}$中所有函數中最接近$f$的函數。 $L^{2}$-範數 因此，名稱最佳近似結果。我們可以將最佳逼近結果與插值估算一起使用研究誤差$f-P_{h} f$取決於網格尺寸。這樣，我們可以遵循基本的所謂先驗誤差估計。 定理1.2。在 $L^{2}$ - 投影$P_{h} f$ 滿足估計 \xa0 $\\left\\|f-P_{h} f\\right\\|_{L^{2}(I)}^{2} \\leq C \\sum_{i=1}^{n} h_{i}^{4}\\left\\|f^{\\prime \\prime}\\right\\|_{L^{2}\\left(I_{i}\\right)}^{2}$\xa0 \xa0( 1.54) \xa0 證明。從最佳逼近結果開始，選擇內插值 $v=\\pi f$\xa0，並使用命題1.1的插值誤差估計，  $\\left\\|f-P_{h} f\\right\\|_{L^{2}(I)}^{2} \\leq\\|f-\\pi f\\|_{L^{2}(I)}^{2}$\xa0 \xa0( 1.55) $\\leq \\sum_{i=1}^{n}\\|f-\\pi f\\|_{L^{2}\\left(I_{i}\\right)}^{2}$\xa0 \xa0( 1.56) $\\leq \\sum_{i=1}^{n} C h_{i}^{4}\\left\\|f^{\\prime \\prime}\\right\\|_{L^{2}\\left(I_{i}\\right)}^{2}$\xa0 \xa0( 1.57) \xa0 這證明了估計。 \xa0 定義$ h=max_{1} \\le {\\tiny i} \\le {\\tiny n}\xa0 h{\\tiny i}$\xa0 ，我們得出結論： \xa0 $\\left\\|f-P_{h} f\\right\\|_{L^{2}(I)} \\leq C h^{2}\\left\\|f^{\\prime \\prime}\\right\\|_{L^{2}(I)}$\xa0 \xa0( 1.58) \xa0 因此，隨著最大網格尺寸h的增加，$L^{2}$ 誤差$\\left \\| f-P{\\tiny h} f \\right \\| _{L^2(I)}^{}$ 趨於零 。 \xa0 \xa0', 'tags': '', 'url': '1 Dimension.html'}, {'title': '2 Dimension', 'text': '4.7 \xa0 狄利克雷(Dirichlet)問題 \xa0 \n 我們考慮以下具有不均勻邊界條件的模型問題 \xa0 ： 找到u使 \xa0 $-\\Delta u=f, \\quad$ in $\\Omega$\xa0 \xa0 ( 4.111a) $u=g_{D}, \\quad \\text { on } \\partial \\Omega$ \xa0 \xa0 ( 4.111b) \xa0  \xa0\xa0 \xa0 其中$f$ 和 $g_{D}$ 給出了函數。 \xa0 由於邊界條件$u=g_{D}$，此問題具有不同的試驗和試驗空間。試驗空間由下式給出：$V_{g_{D}}=\\left\\{v:\\|v\\|_{L^{2}(\\Omega)}+\\|\\nabla v\\|_{L^{2}(\\Omega)}<\\infty,\\left.v\\right|_{\\partial \\Omega}=g_{D}\\right\\}$\xa0  ( 4.112) \xa0 \xa0\xa0 而測試空間由$V_{0}$給出。乘以$f=-\\Delta u$通過測試函數$v \\in V_{0}$並使用格林的公式，我們有 \xa0 $\\int_{\\Omega} f v d x=-\\int_{\\Omega} \\Delta u v d x$\xa0 \xa0( 4.113)$=\\int_{\\Omega} \\nabla u \\cdot \\nabla v d x-\\int_{\\partial \\Omega} n \\cdot \\nabla u v d s$\xa0 \xa0 ( 4.114) $=\\int_{\\Omega} \\nabla u \\cdot \\nabla v d x$\xa0 \xa0 ( 4.115) \xa0 \xa0\xa0 \xa0 \xa0 由於$u=0$在$\\partial \\Omega$上。因此，變式表述為：找到$u \\in V_{g_{D}}$使得$\\int_{\\Omega} \\nabla u \\cdot \\nabla v d x=\\int_{\\Omega} f v d x, \\quad \\forall v \\in V_{0}$\xa0 \xa0 ( 4.116) \xa0 我們假設$g_{D}$是連續分段線性的限制功能到邊界。換句話說，有一個函數$u_{h, g_{D}} \\in V_{h}$使得$u_{h, g_{D}}=g_{D}$在$\\partial \\Omega$上。如果不是這樣，我們首先必須通過一個函數來近似$g$在$V_{h}$中 ，例如在邊界上使用線性插值。 仿射子空間介紹 $V_{h, g_{D}}=\\left\\{v \\in V_{h}:\\left.v\\right|_{\\partial \\Omega}=g_{D}\\right\\}$\xa0 \xa0\xa0 ( 4.117) \xa0 \xa0 \xa0 有限元方法顯示為：找到$u_{h} \\in V_{h, g_{D}}$使得 $\\int_{\\Omega} \\nabla u_{h} \\cdot \\nabla v d x=\\int_{\\Omega} f v d x, \\quad \\forall v \\in V_{h, 0}$\xa0 \xa0\xa0 ( 4.118) 為了導出$u_{h}$的等式，我們將其寫為 $u_{h}=u_{h, 0}+u_{h, g_{D}}$\xa0 \xa0\xa0 ( 4.119) \xa0 \xa0 \xa0\xa0 \xa0 其中$u_{h, g_{D}}$是$V_{h, g_{D}}$中的給定函數，$u_{h, 0}$適$v_{h, 0}$中的尋找函數。這$u_{h}$的構造將滿足邊界條件，因為$u_{h, g_{D}} =g_{D}$和$u_{h, 0}=0$在邊界上。由於$u_{h, g_{D}}$是已知的，因此僅需確定$u_{h, 0}$即可。在這樣做，我們得到以下等式：找到$u_{h} \\in v_{h, 0}$使得$\\int_{\\Omega} \\nabla u_{h, 0} \\cdot \\nabla v d x=\\int_{\\Omega} f v d x-\\int_{\\Omega} \\nabla u_{h, g_{D}} \\cdot \\nabla v d x, \\quad \\forall v \\in V_{h, 0}$ (4.120) 這是與原始問題相同的問題，但右手邊已修改。使用伽遼金法正交性可以表明$u_{h, 0}$獨立於$u_{h, g_{D}}$ 的 特定選擇。因此，通常在所有內部將$u_{h, g_{D}}$選擇為零節點。 \xa0 解決方程，令$n_{p}$為節點數，並假設第一個$n_{i}$這些是內部的，而其餘的$n_{g}=n_{p}-n_{i}$是外部的，並且位於網格邊界。此外，令A和b為通常的$n_{p} \\times n_{p}$剛度矩陣和$n_{p} \\times 1$負載向量，從assema輸出。 我們有$n_{p} \\times n_{p}$線性系統 \xa0 $\\left[\\begin{array}{cc}A_{00} & A_{0 g} \\\\ 0 & I\\end{array}\\right]\\left[\\begin{array}{l}\\xi_{0} \\\\ \\xi_{g}\\end{array}\\right]=\\left[\\begin{array}{l}b_{0} \\\\ b_{g}\\end{array}\\right]$ \xa0 \xa0\xa0 \xa0 ( 4.121) \xa0 其中$A_{00}$是$A$的左上$n_{i} \\times n_{i}$塊，$A_{0 g}$是$n_{i} \\times n_{g}$右上塊$A$的$I$是$n_{g} \\times n_{g}$恆等式矩陣，$b_{0}$是$b$的第一個$n_{i} \\times 1$塊，$b_{g}$是$n_{g} \\times 1$節點值為$g_{D}$的向量，$\\xi 0$為$n_{i} \\times 1$節點值為$u_{h, 0}$的向量，以及$\\xi g$ $n_{g} \\times 1$矢量，其節點值為$u_{h, g_{D}}$。 重新排列第一個$n_{i}$方程我們得到$n_{i} \\times n_{i}$線性系統\xa0 $A_{00} \\xi_{0}=b_{0}-A_{0 g} \\xi_{g}=b_{0}-A_{0 g} g$\xa0 (4.122)\xa0\xa0 \xa0\xa0 從中可以獲得$\\xi 0$。將此直接轉換為MATLAB代碼。 假設我們有一個固定了所有邊界節點數的向量，另一個向量$g$保持相應的節點值。 然後，我們可以建立並解決（4.122）以下代碼。  \n [A,unused,b] = assema(p,t,...); % assemble A and b  np = size(p,2); % total number of nodes  fixed = unique([e(1,:) e(2,:)]); % boundary nodes  free = setdiff([1:np],fixed); % interior nodes  b = b(free)-A(free,fixed)*g; % modify A  A = A(free,free); % modify b  xi = zeros(np,1); % allocate solution  xi(fixed) = g; % insert fixed node values  xi(free) = A\\b; % solve for free node values  \xa0 \n 4.8 諾伊曼問題 \xa0 \n 接下來，我們考慮以下模型問題：找到這樣的$u$ \xa0 $$-\\Delta u=f, \\quad in \\Omega$$\xa0 \xa0\xa0 ( 4.123a) $$n \\cdot \\nabla u=g_{N}, \\quad \\text { on } \\partial \\Omega$$  \xa0\xa0 \xa0 ( 4.123b) \xa0 其中$ f $和$ g_ {N} $被賦予函數。 \xa0 讓我們嘗試在$V=\\left\\{v:\\|v\\|_{L^{2}(\\Omega)}+\\right.\\left.\\|\\nabla v\\|_{L^{2}(\\Omega)}<\\infty\\right\\}$空間中尋求此問題的解決方案。 \xa0 \xa0 像往常一樣，將$f=-\\Delta u$乘以的測試函數$v \\in V$，並使用格林公式進行積分$\\int_{\\Omega} f v d x=-\\int_{\\Omega} \\Delta u v d x$\xa0 \xa0 \xa0(4.124) $=\\int_{\\Omega} \\nabla u \\cdot \\nabla v d x-\\int_{\\partial \\Omega} n \\cdot \\nabla u v d s$\xa0 \xa0 \xa0(4.125) $=\\int_{\\Omega} \\nabla u \\cdot \\nabla v d x-\\int_{\\partial \\Omega} g_{N} v d s$\xa0 \xa0 \xa0(4.126) \xa0 因此，變式表述為：找到$v \\in V$，使得$\\int_{\\Omega} \\nabla u \\cdot \\nabla v d x=\\int_{\\Omega} f v d x+\\int_{\\partial \\Omega} g_{N} v d s, \\quad \\forall v \\in V$\xa0 \xa0 \xa0(4.127) \xa0 在這裡，通過選擇測試函數$ v $作為任何常數，可以使梯度$\\ nabla v$消失。結果，只有且僅當$f$和$ g_ {N} $滿足所謂的守恆性質時，$（4.127）$才是可解的。$\\int_{\\Omega} f d x+\\int_{\\partial \\Omega} g_{N} d s=0$\xa0 ( 4.128) 但是，只能由一個常數來確定解決方案$ u $。要修復此常數並獲得唯一的解決方案，一個常見的技巧是施加附加約束 \xa0 $\\int_{\\Omega} u d x=0$\xa0 \xa0(4.129) \xa0 \xa0\xa0 \xa0 \xa0 這樣做時，尋找$ u $到（4.127）的解的合適位置是空格 $\\bar{V}=\\left\\{v \\in V: \\int_{\\Omega} v d x=0\\right\\}$ ( 4.130) \xa0 其中僅包含平均值為零的函數。這就是所謂的商空間。現在，有限元方法採用以下形式：找到$\\in \\bar{V}_{h} \\subset \\bar{V}$使得 $\\int_{\\Omega} \\nabla u_{h} \\cdot \\nabla v d x=\\int_{\\Omega} f v d x+\\int_{\\partial \\Omega} g_{N} v d s, \\quad \\forall v \\in \\bar{V}_{h}$ \xa0 \xa0(4.131)\xa0 \xa0 其中$ \\bar {V} _ {h} $是均值為零的所有連續分段線性空間。商空間$ \\bar {V} _ {h} $在理論上最為重要，因為在實踐中，剛度矩陣和載荷矢量的組裝是在不受約束的空間$ V_ {h} $上完成的。因此，令$ A $和$ b $分別為通常的$ n_ {p} \\times n_{p} $剛度矩陣和$ n_{p} \\times 1 $負載矢量，其中$ n_{p} $網格中的節點總數。零均值約束$ \\int _ {\\Omega} u_{h} dx = \\sum_{j = 1} ^ {n_{p}} \\xi_{j} \\int _ {\\Omega} \\varphi_{j} dx = 0可以通過拉格朗日乘數技術強制執行$。基本思想很簡單，它依賴於解決方案，即對$ A \\xi = b $的解$ \\xi $（即$ u_{h} $的$ n_{p} $節點值）也是小化二次形式$ J（\\xi）= \\frac {1} {2} \\xi ^ {T} A \\xi- \\xi ^ {T} b $的極小值。確實，如果$ \\xi $恰好受一組$ n_ {c}<n_{p} $約束$ C \\xi = 0 $，而$ C $是給定的$ n_{c} \\times n_{p} $矩陣，則優化的基本結果表明，可以通過尋找所謂的拉格朗日方程的固定點來找到$ J $的約束最優值。 $$ L(\\xi, \\mu)=J(\\xi)-\\mu^{T} C \\xi $$(4.132) \xa0 \xa0 其中$ n_{c} \\times 1 $向量$ \\mu $被稱為拉格朗日乘數。 相對於$ \\xi $和$ \\mu $區分$ L $並使用一階最優性條件$ \\partial _ {\\xi} L = \\partial _ {\\ mu} L = 0 $導致線性系統擴充$\\left[\\begin{array}{ll}A & C^{T} \\\\ C & 0\\end{array}\\right]\\left[\\begin{array}{l}\\xi \\\\ \\mu\\end{array}\\right]=\\left[\\begin{array}{l}b \\\\ 0\\end{array}\\right]$(4.133) \xa0 從中可以獲得$ \\xi $。 對我們來說，$ C $只是$ 1 \\times n_{p} $矩陣，其條目為$ C_ {1 i} = $ $ \\int_{\\Omega} \\varphi_{i} dx。$拉格朗日乘數$ \\mu $ 可能是作為一種強制執行約束的力量。 因為$ u_{h} $的零平均值是一個約束條件，不會改變根本的諾伊曼問題的解決方案，因此力$\\mu $應該消失或至少很小。 \xa0 \n 4.9特徵值問題 \xa0 \n 我們模型的最後一個問題是特徵值問題：找到函數$u$和數字$\\lambda$，使得$-\\Delta u=\\lambda u, \\quad$ in $\\Omega$ (4.134a)  $n \\cdot \\nabla u=0, \\quad$ on $\\partial \\Omega$ (4.134b)  在這裡，為簡單起見，我們假設邊界上的諾伊曼條件，但是狄利克雷條件也可以適用。 邊界條件都一樣但必須是同質的。  特徵值問題的顯著特徵是我們同時尋找函數$u$和數字$\\lambda$。 我們稱$u$為本徵函數或本徵模，$\\lambda$為特徵值，該對稱$(u, \\lambda)$為特徵對。  從操作員的頻譜理論可以得出，解數$\\left(u_{n}, \\lambda_{n}\\right), n=1,2, \\ldots$的特徵值非負遞增，數量可觀。 對於諾伊曼條件，常數函數是特徵值為零的唯一特徵向量，所有其他特徵值均為正，並且隨著$ n $趨於無窮，它們也趨於無窮。 對於狄利克雷條件，不存在零特徵值。 與不同特徵值$ \\lambda_{n} $和$ \\lambda_{m} $相關的特徵向量$ u_{n} $和$ u_{m} $在以下意義上是正交的  $\\int_{\\Omega} \\nabla u_{n} \\cdot \\nabla u_{m} d x=\\int_{\\Omega} u_{n} u_{m} d x=0$ (4.135)  與一個特徵值關聯的所有特徵向量的集合是稱為特徵空間的向量空間，特徵空間的維數稱為特徵值的多重性。 我們可以在本徵空間中選擇一個滿足正交性條件（4.135）的基礎。 因此，正交條件（4.135）對於所有$ n $和$ m $都成立，其中$ n \\neq m $。為了構造有限元方法，我們照常進行。 將$ \\lambda u = $ $-\\Delta u $乘以測試函數$ v \\in V $，然後使用格林公式進行積分，我們得到  \n $\\lambda \\int_{\\Omega} u v d x=-\\int_{\\Omega} \\Delta u v d x$ (4.136) $=\\int_{\\Omega} \\nabla u \\cdot \\nabla v d x-\\int_{\\partial \\Omega} n \\cdot \\nabla u v d s$ (4.137) $=\\int_{\\Omega} \\nabla u \\cdot \\nabla v d x$ (4.138)  因此，變式表述為：找到$u \\in V$和$\\lambda \\in \\mathbb{R}$使得 $\\int_{\\Omega} \\nabla u \\cdot \\nabla v d x=\\lambda \\int_{\\Omega} u v d x, \\quad \\forall v \\in V$ (4.139)  相應的有限元方法如下：找到$u_{h} \\in V_{h}$和$\\lambda_{h} \\in \\mathbb{R}$使得  $\\int_{\\Omega} \\nabla u_{h} \\cdot \\nabla v d x=\\lambda_{h} \\int_{\\Omega} u_{h} v d x, \\quad \\forall v \\in V_{h}$ (4.140)  有限元方法不是導致線性系統，而是導致所謂的形式的廣義代數特徵值問題  $A \\xi=\\lambda M \\xi$ (4.141)  其中$ A $和$ M $是通常的剛度和質量矩陣，而$ \\xi $是具有$ u_ {h} $節點值的向量。特徵對存在$\\left(\\xi_{n}, \\lambda_{n}\\right), n=1, \\ldots, n_{p}$和$ n_{p} $，有限元空間的維數來自對稱矩陣的頻譜理論。 對應的特徵向量$ \\ xi_{i} $相對於正交到$ A $和$ M $。 如果$ \\xi $是一個特徵向量，那麼對於任何實數$ t $而言，$ t \\xi $也是本徵向量。 在實踐中，通常將特徵向量標準化，以使它們具有單位$ L ^ {2} $-範數。  在MATLAB中，可以使用eigs例程解決廣義的稀疏特徵值問題。下面我們展示瞭如何計算單位盤上幅度最小的前五個本徵模。 矩陣$ A $和$ M $的彙編是使用assema例程完成的。  g = ’circleg’; % built-in geometry of a cricle  [p,e,t] = initmesh(g,’hmax’,0.1); % mesh  [A,M] = assema(p,t,1,1,0); % assemble A and M  [Xi,La] = eigs(A,M,5,’SM’); % solve A*Xi=La*M*Xi  pdesurf(p,t,Xi(:,1)) % plot 1:st eigenmode  \xa0 \n 4.10自適應有限元方法 \xa0 \n \xa0 \n 如我們所見，後驗誤差估計是可計算誤差估計，可用於指導自適應網格細化。 這樣可以迭代地提高有限元解決方案的精度，同時節省計算資源。 接下來，我們為泊松方程製定自適應有限元。 為簡單起見，我們將注意力集中在簡單模型問題（4.5）上（即$-\\Delta u = f $在$ \\Omega $中，和在$ \\partial \\Omega$上的$u = 0$）。 \n 4.10.1後驗誤差估計 \xa0 \n 眾所周知，連續分段線性有限元解$u_{h}$的梯度$\\nabla u_{h}$通常是不連續的分段常數矢量。 因此，當正交地跨一個元素的邊界移動到相鄰元素時，法線導數$n \\cdot \\nabla u_{h}$中會有一個躍遷。此躍遷表示為$\\left [n \\cdot \\nabla u_{h} \\right]$，並在後驗誤差分析中發揮關鍵作用。 定理4.12。 由（4.13）定義的有限元解$ u_{h} $滿足估計  $\\left\\|u-u_{h}\\right\\| \\|^{2} \\leq C \\sum_{K \\in \\mathcal{K}} \\eta_{K}^{2}\\left(u_{h}\\right)$ (4.142)  其中元素殘差$\\eta_{K}\\left(u_{h}\\right)$定義為 $\\eta_{K}\\left(u_{h}\\right)=h_{K}\\left\\|f+\\Delta u_{h}\\right\\|_{L^{2}(K)}+\\frac{1}{2} h_{K}^{1 / 2}\\left\\|\\left[n \\cdot \\nabla u_{h}\\right]\\right\\|_{L^{2}(\\partial K \\backslash \\partial \\Omega)}$ \xa0 \xa0 \xa0\xa0 ( 4.143) 在這，$\\left [n \\cdot \\nabla u_{h} \\right]$表示$u_{h}$的正態導數在元素$\\mathrm {K}$的（內部）邊上的跳躍。另外，因為$u_ {h}$在$K$上是線性的，所以$\\Delta, u_{h} =0$。  證明。 讓$ e = u-u_{h} $是我們遇到的錯誤 $\\|e\\|^{2}=\\|\\nabla e\\|_{L^{2}(\\Omega)}^{2}=\\int_{\\Omega} \\nabla e \\cdot \\nabla e d x=\\int_{\\Omega} \\nabla e \\cdot \\nabla(e-\\pi e) d x$ (1.144)  在這裡我們使用Galerkin正交（4.46）減去一個插值$\\pi e \\in V_{h, 0}$ 至 $e$將其分解為元素的總和，並使用積分我們進一步擁有的零件 $\\sum_{K \\in \\mathcal{K}} \\int_{K} \\nabla e \\cdot \\nabla(e-\\pi e) d x=\\sum_{K \\in \\mathcal{K}}-\\int_{K} \\Delta e(e-\\pi e) d x+\\int_{\\partial K} n \\cdot \\nabla e(e-\\pi e) d s$ (4.145) $=\\sum_{K \\in \\sigma} \\int_{K}\\left(f+\\Delta u_{h}\\right)(e-\\pi e) d x+\\int_{\\partial K \\backslash \\partial \\Omega} n \\cdot \\nabla e(e-\\pi e) d s$ (4.146)  我們在$K$內部使用了$-\\left.\\Delta e\\right|_{K}=f+\\left.\\Delta u_{h}\\right|_{K}$由於邊界條件為零，因此$e$以及$\\pi e $在$ \\partial \\Omega$上消失。 因此，我們不需要在外部邊緣上集成$n \\cdot \\nabla e（e- \\pi e$，而只需在內部邊緣上集成$n \\cdot \\nabla e（e- \\pi e$。 這樣做時，我們注意到每個邊$ E $有兩個貢獻，即每個元素$ K ^ {\\pm} $共享$E$。 $\\int_{\\partial K+\\cap \\partial K^{-}} n \\cdot \\nabla e(e-\\pi e) d s=\\int_{E}\\left(n^{+} \\cdot \\nabla e^{+}\\left(e^{+}-\\pi e^{+}\\right)+n^{-} \\cdot \\nabla e^{-}\\left(e^{-}-\\pi e^{-}\\right)\\right) d s$ (4.147) 在這裡我們使用符號$v ^ {\\pm} = \\left.v \\right | _ {K ^ {\\pm}}$。 現在，錯誤$e$是連續的，這意味著$\\left.\\left(e^{+}-\\pi e^{+}\\right)\\right|_{E}=\\left.\\left(e^{-}-\\pi e^{-}\\right)\\right|_{E}$，我們可以刪除上標以簡化表示法。 同樣，漸變$\\nabla u$是連續的，表示$\\left.\\left(n^{+} \\cdot \\nabla u^{+}+n^{-} \\cdot \\nabla u^{-}\\right)\\right|_{E}=0$。 但是，梯度$\\left.\\nabla u_{h}\\right|_{E}$通常不是連續的，因為它只是一個分段常數向量。 因此，考慮到$n \\cdot \\nabla u_ {h}$在$K ^ {+} $和$ K ^ {-}$上可能有所不同 $\\int_{E}\\left(n^{+} \\cdot \\nabla e^{+}(e-\\pi e)+n^{-} \\cdot \\nabla e^{-}(e-\\pi e)\\right) d s =-\\int_{E}\\left(n^{+} \\cdot \\nabla u_{h}^{+}+n^{-} \\cdot \\nabla u_{h}^{-}\\right)(e-\\pi e) d s$\xa0 (4.148)  $=-\\int_{E}\\left[n \\cdot \\nabla u_{h}\\right](e-\\pi e) d s$\xa0 (4.149)  由此推斷 $\\sum_{K \\in \\mathcal{K}} \\int_{\\partial K \\backslash \\partial \\Omega} n \\cdot \\nabla e(e-\\pi e) d s=-\\sum_{E \\in \\mathcal{E}_{I}} \\int_{E}\\left[n \\cdot \\nabla u_{h}\\right](e-\\pi e) d s$ (4.150) 通過簡單地在$K ^ {+}$上分配一半的跳轉$[n$. $\\left.\\nabla u_{h}\\right]\\left.\\right|_{E}$和在$K ^ {-}$上分配一半的跳轉，就可以得出元素的總和，我們得到誤差表示公式 $\\|\\mid\\|^{2}=\\sum_{K \\in \\mathcal{K}} \\int_{K}\\left(f+\\Delta u_{h}\\right)(e-\\pi e) d x-\\frac{1}{2} \\int_{\\partial K \\backslash \\partial \\Omega}\\left[n \\cdot \\nabla u_{h}\\right](e-\\pi e) d s$ \xa0 \xa0\xa0 ( 4.151) 讓我們分別估計右側的兩個項。可以使用柯西-舒瓦茲不等式估算內部貢獻 然後是標準插值誤差估計。 通過這樣做，我們得到 $\\int_{K}\\left(f+\\Delta u_{h}\\right)(e-\\pi e) d x \\leq\\left\\|f+\\Delta u_{h}\\right\\|_{L^{2}(K)}\\|e-\\pi e\\|_{L^{2}(K)}$\xa0 (4.152) $\\leq\\left\\|f+\\Delta u_{h}\\right\\|_{L^{2}(K)} C h_{K}\\|D e\\|_{L^{2}(K)}$\xa0 (4.153) 對於邊緣貢獻，我們需要縮放的跡線不等式 $\\|v\\|_{L^{2}(\\partial K)}^{2} \\leq C\\left(h_{K}^{-1}\\|v\\|_{L^{2}(K)}^{2}+h_{K}\\|\\nabla v\\|_{L^{2}(K)}^{2}\\right)$\xa0 (4.154) 再次使用這個和柯西-舒瓦茲不等式，我們得到 $\\int_{\\partial K}\\left[n \\cdot \\nabla u_{h}\\right](e-\\pi e) d s \\leq\\left\\|\\left[n \\cdot \\nabla u_{h}\\right]\\right\\|_{L^{2}(\\partial K)}\\|e-\\pi e\\|_{L^{2}(\\partial K)}$ (4.155)  $\\leq\\left\\|\\left[n \\cdot \\nabla u_{h}\\right]\\right\\|_{L^{2}(\\partial K)} C h_{K}^{1 / 2}\\|D e\\|_{L^{2}(K)}$\xa0 (4.156) 現在，估計值從（4.153）和（4.157）一起得出。 \xa0 \xa0 我們指出，只要四面體網格上的所有積分都被四面體面上的積分代替，則上述後驗估計在四面體網格上也適用於三個維度。 當然，三角形上的積分也必須用四面體上的積分代替。 \xa0 4.10.2自適應網格細化 \xa0 \n 二維和三維的網格細化比一維複雜得多。特別是，在為高維網格構造網格細化算法時，要考慮兩個重要問題。首先，不允許使用無效元素（即具有懸掛節點的元素），並且我們希望細化盡可能少的元素，這些元素不在要細化的元素列表中。其次，重要的是將網孔中的最小角度保持盡可能大。否則，隨著我們的不斷完善，有限元解決方案的質量可能會下降。另外，當在彎曲的外部區域邊界上細化元素時，應考慮曲率，以便細化的網格比未細化的網格更好地表示域幾何形狀。這涉及在邊界上移動新創建的節點，這很麻煩，因為這可能會導致元素質量低下甚至是倒置元素。對於三角形和四面體網格，用於網格的最流行算法 \xa0 \n 細化是： \xa0 \n \n Rivara精修，或最長的邊緣平分 。 \n 定期細化或紅綠細化。 接下來，我們將詳細描述這些內容。 \xa0 我們注意到PDE-Toolbox支持常規和Rivara細化。 \xa0 \n \n 4.10.2.1Rivara優化 \xa0 \xa0 \n 在Rivara方法中，總是通過從最長邊的中點到對角插入新邊來對三角形進行精化。 不言而喻的希望是，可以通過始終在要精煉的三角形內分割最長的邊來保持網格的質量。 Rivara的改進依賴於終端邊緣和最長邊緣傳播路徑的概念。 如果$E$是共享$E$的三角形的最長邊，則邊緣$E$稱為末端。共享$E$的三角形集合稱為末端星形。 三角形$ K $的最長邊傳播路徑，縮寫為$ \\operatorname {LEPP}（K）$，是從$K$開始並依次移動到具有最長邊的相鄰三角形直到到達的三角形序列 終端邊緣。 利用這些概念，Rivara及其[53]用以下算法總結了最長的邊緣二等分細化方法： (53. M.-C. Rivara，C.Calderon，A.Fedorov和N.Chrisochoides。 用於3維網格生成的並行解耦終端邊緣對分方法。 計算機工程，22：111–119， 2006年8月。) Algorithm 12 Rivara Refinement.  1: 給定一個網格$K$並設置元素$S$進行細化。  2: for $K \\in \\mathcal{S}$ do  3: while $K \\in M$ do  4: 找到$ \\operatorname {LEPP}（K）$和關聯的終端邊緣。  5: 細化終端星。  6: end while  7: end for 末端星形的細化通常是通過將末端邊緣平分並將構成星形的兩個三角形劃分為四個較小的子三角形來完成的。 如果終極邊緣位於邊界上，則終極星只包含一個 \xa0 圖4.5 目標三角形$K$的Rivara細化。（a）初始網格，（b）第一細化步驟，（c）第二細化步驟，以及（d）用$K$細化的最終網格 \xa0 三角劃分。 請注意，末端星形的細化不會導致星形以外的其他細化。 Rivara算法的計算瓶頸是$ \\operatorname {LEPP}（K）$ 的重複計算，這對於大型網格而言可能會變得昂貴。 圖4.5說明了在小網格上目標三角形$K$的Rivara細化過程。 \xa0 \n 4.10.2.2定期優化 \xa0 \n 常規細化包括通過在每個邊的中點插入一個新節點，將每個要細化的三角形分成四個較小的三角形。這給出了四個子三角形，它們與原始（母）三角形一致。 \xa0 因此，子與母具有相同的素質。這稱為紅色優化。參見圖4.6a。在邊緣上插入新的新節點意味著與細化三角形相鄰的三角形會成為懸掛節點，因此也必須細化。這是通過在懸掛節點和對角之間插入新邊來完成的。這稱為綠色細化。參見圖4.6b。僅綠色細化如果存在一個懸掛節點，則應用此選項。否則，將插入額外的節點，以便可以應用紅色優化。重複此過程，直到沒有剩餘的掛起節點為止。結果，精製的網格具有由綠色精製的三角形圍繞的紅色精製的三角形區域。自然，綠色精緻三角形的質量不如紅色三角形。因此，在隨後的細化循環中，這是慣例請勿使用綠色細化功能反复細化以前用綠色標記的三角形。 \xa0 圖4.6（a）紅色和（b）綠色三角形用於細化 \xa0 \n 圖4.7一個正方形的紅色綠色細化插圖，其中兩個三角形變成一個紅色和一個三角形 三角形的綠色類型。 （a）初始網格，（b）懸掛節點（●），以及（c）最終網格 圖4.7展示了一個正方形的紅色綠色細化，其中兩個三角形分別為一個紅色和一個綠色三角形。 首先使用紅色細化對下部三角形進行細化。 這將導致一個懸掛的節點，必須使用上部三角形的綠色細化來注意這一點。 \xa0 \n 4.10.3\xa0 使用MATLAB的自適應有限元 \xa0 \n 在MATLAB中編寫自適應有限元求解器相對容易。 \xa0 首先，我們創建一個（粗）初始網格 \xa0 g = ’cardg’; % predefined geometry of a cardioid  \xa0 [p,e,t] = initmesh(g,’hmax’,0.25);  然後我們計算有限解$u_{h}$  \xa0 [A,unused,b] = assema(p,t,...);  \xa0 % .. application of B.C. etc ..  \xa0 xi = A\\b;  下一步是評估由（4.143）定義的元素殘差K。 這可以使用內置的常規pdejmps完成，即 \xa0 eta = pdejmps(p,t,...);  pdejmps例程最初用於計算元素殘差到$-\\nabla \\cdot（c \\nabla u）+ a u = f$，因此其語法為  \xa0 eta = pdejmps(p,t,c,a,f,xi,1,1,1);  其中三個輸入$\\mathrm {c}，\\mathrm {a} $和$ \\mathrm {f}$可以是常量，也可以是行向量，用於指定係數$c，a$和 $f$在三角形的質心處。 作為我們的優化標準，我們選擇最容易出錯的$ 10 ％$最容易出錯的元素。  \xa0 tol = 0.9*max(eta);  \xa0 elements = find(eta > tol);  在這些調用之後，矢量元素包含元素的元素編號待完善。實際的優化是通過內置的finemesh例程完成的。  \xa0 [p,e,t] = refinemesh(g,p,e,t,elements,’regular’);  此處使用的網格細化算法是常規細化。 我們用簡單停止標準，即網格中的最大元素數量不得超過10000。 下面我們列出了一個完整的例程，用於在形狀像心形的域$\\Omega$上自適應求解泊松方程$-\\Delta u = 1$，在邊界$\\partial \\Omega$上具有$u = 0$。 function AdaptivePoissonSolver2D()  % set up geometry g = ’cardg’;  % create initial mesh [p,e,t] = initmesh(g,’hmax’,0.25);  % while not too many elements, do  while size(t,2) < 10000 \xa0 %\xa0 assemble \xa0stiffness matrix A, and load vector b \xa0 [ A,unused,b ] =\xa0 assema ( p,t ,1,0,1); \xa0 %\xa0 get \xa0 the number of nodes \xa0 np = size(p,2); \xa0 % enforce zero Dirichlet BC  \xa0 fixed = unique([e(1,:) e(2,:)]); \xa0 free = setdiff([1:np],fixed);\xa0 \xa0 \xa0 \xa0% solve for finite element solution  \xa0 xi = zeros(np,1);  \xa0 xi(free) = A\\b; \xa0 figure(1), pdesurf(p,t,xi)  \xa0 xlabel(’x’), ylabel(’y’), title(’u_h’)  \xa0 % compute element residuals  \xa0 eta = pdejmps(p,t,1,0,1,xi,1,1,1);  \xa0 % choose a selection criteria \xa0 tol = 0.8*max(eta);  \xa0 % select elements for refinement  \xa0 elements = find(eta > tol)’;  \xa0 % refine elements using regular refinement 圖4.8解決方案$u = a e ^ {-a r ^ {2}}$的問題的自適應網格。 （a）兩項 細化 ，（b）四種 細化 ，（c）六項 細化 ，和（d）十項 細化 \xa0 [p,e,t] = refinemesh(g,p,e,t,elements,’regular’);  \xa0 figure(2), pdemesh(p,e,t)  end 為了說明自適應網格細化，讓我們解決問題 \xa0 $-\\Delta u=4 a^{2}\\left(1-a r^{2}\\right) e^{-a r^{2}}, \\quad$ in $\\Omega=[0,1]^{2}$ \xa0 \xa0\xa0 ( 4.158a) \xa0 $u=0$ on $\\partial \\Omega$ \xa0( 4.158b) \xa0 其中$a$是參數，$r$是距單位正方形$\\Omega = [0,1] ^ {2}$的中心的距離。如果選擇$a$足夠大，則說$a = 400$ ，則解析解由$u = ae ^ {-ar ^ {2}}$給出。這個問題在計算上很苛刻，因為該解決方案是一個非常窄的脈衝，具有很強的局部梯度，中心在$（0.5,0.5 \xa0 ) $。 因此，為了獲得良好的有限元逼近，我們期望必須通過在該點放置許多三角形來解析此點周圍的區域，但是也許我們在其他區域中不需要那麼多的三角形。 圖 4.8 和 4.9 顯示了 \xa0 圖4.9對$u = a e ^ {-a r ^ {2}}$。的自適應計算近似值（a）兩種 細化 ，（b）四種 細化 ，（c）六種 細化 ，和（d）十種 細化 \xa0 運行上述十個自適應循環的自適應代碼的結果，其中25％的優化規則。 我們看到預期區域的確確實很完善。 \xa0 \n 4.10.4基於對偶的後驗誤差估計 \xa0 \n 在許多應用中，最重要的不是泊松方程（4.5）本身的解，而是其他一些涉及$u$的量。 該量通常可以表示為線性函數 $m(u)=\\int_{\\Omega} \\psi v d x$\xa0\xa0 \xa0\xa0 ( 4.159) \xa0 其中$\\ psi$是要適當選擇的加權函數。 例如，選擇$\\psi = | \\Omega | ^ {-1} $給出$ \\Omega$中$u$的平均值。我們說$m（\\cdot）$表示計算的目標。 \xa0 要斷言我們獲得了感興趣數量的準確值，我們必須找到一種監控誤差的方法 $m(e)=m(u)-m\\left(u_{h}\\right)$ \xa0 \xa0\xa0 ( 4.160) 確實，我們希望$m（e）$盡可能地小，並且需要最少的計算工作。 更準確地說，使用盡可能小的網格，$m（e）$應該小於預定義的公差。 為此，我們重新引入了對偶問題：找到$\\phi \\in V$使得 $-\\Delta \\phi=\\psi, \\quad$ in $\\Omega$ \xa0 \xa0\xa0 ( 4.161a) \xa0 $\\phi=0, \\quad$ on $\\partial \\Omega$ \xa0\xa0 \xa0 \xa0 ( 4.161b) \xa0 回想一下，這讓人想起Nitsche的把戲，其中$\\ psi = e$。 通過使用雙重問題和零件集成，我們可以 \xa0 $m(e)=\\int_{\\Omega} e \\psi d x$\xa0\xa0 \xa0\xa0 ( 4.162) $=\\int_{\\Omega}-e \\Delta \\phi d x$\xa0\xa0\xa0 \xa0\xa0 ( 4.163) \xa0 $=\\int_{\\Omega} \\nabla e \\cdot \\nabla \\phi d x-\\int_{\\partial \\Omega} e n \\cdot \\nabla \\phi d s$ \xa0 \xa0\xa0 ( 4.164) \xa0 $=\\int_{\\Omega} \\nabla e \\cdot \\nabla \\phi d x$  \xa0\xa0 ( 4.165) \xa0 我們在$\\partial \\Omega$上使用$e = 0$來擺脫邊界項。 現在，從Galerkin正交性（4.46）中，選擇$ v$作為$\\phi $的V_{h .0}$中的分段線性插值$\\pi \\phi \\ in$ $$ m(e)=\\int \\nabla e \\cdot \\nabla(\\phi-\\pi \\phi) d x $$ \xa0 \xa0\xa0 ( 4.166) \xa0 $=\\int_{\\Omega} f(\\phi-\\pi \\phi) d x-\\int_{\\Omega} \\nabla u_{h} \\cdot \\nabla(\\phi-\\pi \\phi) d x$ \xa0 \xa0\xa0 ( 4.167) \xa0 通過對每個元素$K$進行部分積分，我們獲得了誤差表示公式 \xa0 $m(e)=\\sum_{K \\in \\mathcal{K}} \\int_{K}\\left(f+\\Delta u_{h}\\right)(\\phi-\\pi \\phi) d x-\\frac{1}{2} \\int_{\\partial K \\backslash \\partial \\Omega}\\left[n \\cdot \\nabla u_{h}\\right](\\phi-\\pi \\phi) d s$ \xa0 \xa0\xa0 ( 4.168) \xa0 它根據有限元解$u_{h}$和對偶$\\phi$提供目標函數$m（\\cdot$中誤差的精確值。當然，這需要有關$ \\phi$的知識 ，通常必須用計算的有限元近似值$\\phi_{h} \\approx \\phi$代替。在這種情況下，對於術語$\\phi_{h}-\\pi \\phi_{h}$ 在某種意義上，必須使用比$u_{h}$更高階的元素來計算$\\phi_{h}$。這是一個主要的問題，因為它可能會變得計算量大。 但是，幸運的是，經常可以提供$\\phi_{h} $的計算。 現在，假設$\\phi $（或$\\phi_{h}$）足夠平滑，我們可以使用標準插值估計來估計錯誤表示公式中的項，這將產生以下後驗錯誤估計。 定理4.13。 由（4.13）定義的有限元解$u_ {h}$滿足估計 $m(e) \\leq C \\sum_{K \\in \\mathcal{K}} \\eta_{K}\\left(u_{h}, \\phi\\right)$ \xa0 \xa0\xa0 ( 4.169) \xa0 其中所謂的元素指標$\\eta_{K}\\left(u_{h}, \\phi\\right)=\\rho_{K}\\left(u_{h}\\right) \\omega_{K}(\\phi)$是元素殘差$\\rho_{K}\\left(u_{h}\\right)$與每個元素K上定義的元素權重$\\omega_{K}(\\phi)$的乘積，  $\\rho_{K}\\left(u_{h}\\right)=\\left\\|f+\\Delta u_{h}\\right\\|_{L^{2}(K)}+\\frac{1}{2} h_{K}^{-1 / 2}\\left\\|\\left[n \\cdot \\nabla u_{h}\\right]\\right\\|_{L^{2}(\\partial K \\backslash \\partial \\Omega)} $\xa0 \xa0 \xa0(4.170) $$ \\omega_{K}(\\phi)=h_{K}^{2}\\left\\|D^{2} \\phi\\right\\|_{L^{2}(K)} $$ \xa0( 4.171) \xa0 元素指示器可用於識別容易出錯的元素，從而驅動自適應網格的細化。這樣，僅細化對目標函數$m（\\cdot）$中的錯誤有重大貢獻的元素。雙重權重$\\omega_ {K}$的效果非常好，它會自動識別域$\\Omega $對$ m（\\cdot）$影響較大的區域。實際上，對偶包含關於$u$擾動的有關$m（u）$的敏感度信息。這與基於能量範數的網格細化相反，後者不考慮細化元素的位置。還要注意，收斂的形式順序是$h ^ {2}$，因此對於$ m（e）$最優，但是對於$|\\| e| \\mid$來說只有$h$。我們正式地說，因為在細化網格中談論全局網格大小可能是可疑的。但是，使用這種基於對偶的後驗網格細化通常會導致非常有效且便宜的自適應有限元方法。 \xa0 我們提到並非所有目標功能$m（u）$都是可計算的（例如，直接點值$u$）。實際上，$m（u）$通常是$u$的某種平均值。同樣，如果在域邊界$\\partial \\Omega$上定義了感興趣的數量，則可以使用形式為$m（u）= \\int _ {\\partial \\Omega} \\psi uds$的目標函數。在這種情況下，權重函數$\\psi$將通過對偶問題的邊界條件輸入誤差表示公式。 與$\\phi$的對偶問題類似，$u$的問題有時稱為原始問題。 \xa0 為了說明面向目標的網格細化，我們考慮泊松方程$-\\Delta u = f$，選擇$f$使得原始數為$u = \\sin \\left（2 \\pi x_ {1} / 3 \\right）\\sin \\left（2 \\pi x_ {2} / 3 \\right$ \xa0 在平方$\\Omega = [0,3] ^ {2}$。選擇權重$\\psi$，使得對偶為$\xa0 $ 這給出目標值$m（u）= \\int _ {\\Omega} \\psi udx =$ \xa0 $1.849253113061110 \\ cdot \xa0 10 ^{ 6}$ 。 作為元素指標 $\\eta_ {K}$，我們按原樣使用錯誤表示公式（4.168）（ 即，我們不估計這些項 ）。 因此，忽略因正交不足和用 $\\phi_{h} $ 代替 $\\phi $ 而產生的錯誤，我們應該 \xa0 圖4.10網格尺寸$h$與誤差$m( e) $的對數圖 \xa0 表4.1 序列的$m( e) $的收斂性自適應網格 \xa0 具有$\\sum_ {K} \\eta_ {K} = m（e）$。使用連續的分段二次有限元計算近似對偶$\\phi_{h}$。進行八個細化循環，我們得到目標功能$m（e）$中的誤差的圖 4.10 和表 4.1 的收斂結果。從圖中可以看出，$| m（e）|$或多或少地像$h ^ {2}$那樣漸近收斂，在這裡我們選擇網格大小為$h = \\sqrt {2 | \\Omega | / n_{t}}$和$n_{t}$個元素的數量。此外，從表中我們可以看到，$\\sum_ {K \\ in \\mathcal {K}} \\eta_ {K}$中可以準確地預測$ m（e）$。這也可以通過所謂的效率指數來反映。$I _ {\\text {eff}}$，由$I _ {\\mathrm {eff}} = m（e）/ \\sum_ {K \\in \\mathcal {K}} \\eta_ {K}$定義。當然，我們希望效率指數接近1。即使在整個域$ \\ Omega $中都存在全局誤差$e = u-u_ {h}$，對偶$\\phi$用於自動識別相關區域，以保持目標函數誤差$m（e ） $小，因此僅在$\\Omega$的左下角進行網格細化。這在圖4.11中清晰可見，它顯示了最終的網格。 \xa0 \n 圖 4.11 解決方案$u = \\sin \\left（2 \\pi x_ {1} /3 \\right）\\sin \\left（2 \\ pi x_ {2} /3 \\right$的問題的最終網格 \xa0 \n \xa0 \n \xa0 \n \xa0 \xa0 \xa0 \xa0 \n \xa0 \n', 'tags': '', 'url': '2 Dimension.html'}, {'title': 'Abaqus', 'text': "Material:Iron Poisson Ration: 0.3 Young's modulus:200GPa Density:7.874kg/mm^3 \n \n", 'tags': '', 'url': 'Abaqus.html'}, {'title': 'Ansys', 'text': '', 'tags': '', 'url': 'Ansys.html'}, {'title': 'Range3', 'text': '\n 啟動 22G 可攜程式系統後, 假設要將 Range3 的原始碼 clone 到 y:\\project2020 目錄中, 在命令列中, 從 y:\\ 目錄 mkdir project2020, 並 cd project2020 後: \n \n git clone --recurse-submodules \xa0 https://github.com/Range-Software/range3.git \n 雖然 Range3 並無 submodules, 但仍以 --recurse-submodules 取下原始碼. \n \n 以滑鼠進入 y:\\msys64\\ 目錄中, 點擊 mingw64.exe 帶出 shell 命令視窗. \n 在 shell 中, 以 cd /y/project2020/range3 進入 range3 程式碼目錄. \n \n \n 在 range3 目錄中執行: \n \n ./scripts/build.sh --clean && ./scripts/create_package.sh \n 就可完成編譯. 編譯完成的檔案為 Y:\\project2020\\range3\\build-Release\\packages\\range-3.2.4.tar.gz \xa0解開壓縮檔案後, 將可攜系統中的 range3_msys2_dlls_platforms.7z 解開所有 .dll 與對應目錄到 bin (編譯完成後只有 Range.exe 與 RangeSolver.exe 兩個檔案), 就可以執行 Range.exe 進行後續的 CAE 分析. \n \n 上述步驟所完成的目錄位於 \xa0 project2020-2_compile_range3.7z \n \n \n start Y:\\msys64\\mingw64.exe \n cd \\y\\tmp\\fem_ex\\range3 \n ./scripts/build.sh --clean && ./scripts/create_package.sh \n \n 其他開源 CAE \n https://en.z88.de/ \n https://su2code.github.io/ \n https://github.com/FreeFem', 'tags': '', 'url': 'Range3.html'}, {'title': 'Range3 Tutorial', 'text': 'Range3_beam_ex.7z \n \n \n \n Von Mises Stress  displayed on nodes \n \n', 'tags': '', 'url': 'Range3 Tutorial.html'}, {'title': 'Ngsolve', 'text': 'http://web.pdx.edu/~gjay/teaching/mth610_2015.2/TutorialNGSpy.html \n 利用 Pyside2 建立 GUI 介面程式:  https://github.com/mdecourse/ngsgui \n Netgen_presentation.pdf \n https://ngsolve.org/ \n From Comsol to Ngsolve.pdf \n AutoShape_NGsolve.pdf \n 以下採用 Elmer 與 Matlab 的案例或可與 NGSolve 分析結果比較: \n https://www.csc.fi/web/elmer \n https://github.com/romanszewczyk/FEM \n 2019_Modeling the Influence of a MagnetomechanicalEffect on the Permeability Tensor of a Tensductor Core.pdf \n Matlab: \n 2020_HDGlab An open-source implementation of thehybridisable discontinuous Galerkin method inMATLAB.pdf \n Magnetic Field Computation: \n https://github.com/mdecourse/magpylib \n', 'tags': '', 'url': 'Ngsolve.html'}, {'title': 'Application', 'text': 'http://sfepy.org/doc-devel/index.html \n \n \n \n \n \n \n', 'tags': '', 'url': 'Application.html'}, {'title': 'Folding Chair', 'text': 'US6305742_FOLDING MECHANISM FOR FOLDING CHAIR.pdf \n 2019_FOLDING-Swiftset_Brochure-2.pdf \n https://mitylite.com/products/swiftset \xa0 \n \n 分析一下為何這張摺疊椅可以承重超過 400 公斤 \n 與其他專利摺疊椅或產品進行比較分析 \n 利用 Pyslvs-UI 嘗試進行迴避設計 \n \n Collapsible Chair.pdf \n Innovative Design of the Combined Rocking Horse Toy and Folding Chair for Children.pdf \n', 'tags': '', 'url': 'Folding Chair.html'}, {'title': 'Folding Funiture', 'text': 'Foldabilizing Furniture.pdf \n ANALYSIS OF JAPANESE AND FINNISH FURNITURE DESIGN.pdf \n', 'tags': '', 'url': 'Folding Funiture.html'}, {'title': 'Ref', 'text': '', 'tags': '', 'url': 'Ref.html'}, {'title': 'Julia', 'text': 'Julia 是 2012 年出現的高階程式語言, 可以將其視為 21 世紀 Fortran, Python 與 Matlab 合體的新一代運算導向語言. \n http://www.stochasticlifestyle.com/comparison-differential-equation-solver-suites-matlab-r-julia-python-c-fortran/ \n https://discourse.julialang.org/t/ann-gridap-jl-a-feature-rich-finite-element-ecosystem-100-in-julia/42824 \xa0 \n https://github.com/gridap/Gridap.jl \xa0 \n https://gitter.im/Gridap-jl/community \xa0 \n', 'tags': '', 'url': 'Julia.html'}, {'title': 'CMSiMDE', 'text': 'https://websitesetup.org/bootstrap-tutorial-for-beginners/ \n https://colorlib.com/wp/themes/travelify/ \xa0 \n https://github.com/puikinsh/travelify \n 將 cad2_site 搬到 /home/cad2 而 cad2 只是 group \n 以 sudo groupadd cad2 建立 cad2 group \n 以 sudo adduser user1 cad2 將 user1 納入 cad2 group \n cd /home \n sudo chmod -R yen:cad2 cad2 將 cad2 以下所有資料的 owner 設為 yen, group 設為 cad2 \n sudo systemctl restart cmsimde 重新啟動 cmsimde 服務 \n uwsgi.ini 中啟用的 user and group 必須與 cad2_site 資料結構一致, 也就是設為 yen:cad2 \n 如此只要用戶屬於 cad2 群組的用戶都能夠登入後, 進入 /home/cad2/cad2_site 執行 git 指令', 'tags': '', 'url': 'CMSiMDE.html'}]};